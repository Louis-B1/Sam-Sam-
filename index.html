<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paris Investigation : Les Chipies √† la rescousse</title>
    <style>
        /* --- CORE --- */
        body { background: #000; margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

        /* --- UI MESSAGERIE (INTRO) --- */
        #phone-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100; display: flex; justify-content: center; align-items: center;
        }
        #phone-frame {
            width: 360px; height: 700px; background: #111; border-radius: 40px; border: 8px solid #333;
            position: relative; overflow: hidden; display: flex; flex-direction: column;
            box-shadow: 0 0 50px rgba(50,50,50,0.5);
        }
        #chat-header {
            background: #222; padding: 15px; text-align: center; color: #fff; font-weight: bold; border-bottom: 1px solid #333;
            display: flex; align-items: center; justify-content: center; gap: 10px;
        }
        #chat-content {
            flex: 1; background: #0f0f0f; padding: 20px; display: flex; flex-direction: column; gap: 15px; overflow-y: auto;
        }
        .msg {
            max-width: 80%; padding: 10px 15px; border-radius: 15px; font-size: 14px; line-height: 1.4; opacity: 0; animation: popIn 0.3s forwards;
        }
        .msg.received { background: #333; color: #fff; align-self: flex-start; border-bottom-left-radius: 2px; }
        .msg.sent { background: #007AFF; color: #fff; align-self: flex-end; border-bottom-right-radius: 2px; }
        .timestamp { font-size: 10px; opacity: 0.6; margin-top: 5px; text-align: right; }
        @keyframes popIn { from { transform: translateY(10px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        
        #start-btn {
            position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
            background: #25D366; color: #fff; padding: 15px 30px; border-radius: 30px; 
            font-weight: bold; cursor: pointer; display: none; box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            z-index: 101;
        }

        /* --- GAME UI --- */
        #hud {
            position: absolute; top: 20px; left: 20px; z-index: 10; display: none;
        }
        .panel {
            background: rgba(20, 20, 20, 0.85); padding: 15px; border-left: 4px solid #d4af37;
            color: #eee; backdrop-filter: blur(5px); font-family: 'Courier New', monospace;
            margin-bottom: 10px; width: 200px;
        }
        #flashlight {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, transparent 20%, rgba(0,0,0,0.98) 65%);
            pointer-events: none; z-index: 5; mix-blend-mode: multiply;
        }

        /* --- DIALOGUE --- */
        #dialogue-box {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 60%; background: rgba(10,10,10,0.95); border: 1px solid #555; border-top: 4px solid #d4af37;
            padding: 20px; color: #fff; font-family: 'Courier New', monospace; font-size: 18px;
            display: none; z-index: 20; text-align: center;
        }

        /* --- FIN --- */
        #win-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 50;
        }
        #samuel-reveal { height: 50vh; border: 5px solid #fff; margin-bottom: 20px; }
    </style>
</head>
<body>

    <div id="youtube-audio" style="position:absolute; top:-9999px;"></div>

    <div id="phone-screen">
        <div id="phone-frame">
            <div id="chat-header">
                <div style="width:10px; height:10px; background:#0f0; border-radius:50%;"></div>
                Groupe "Les Chipies"
            </div>
            <div id="chat-content">
                </div>
        </div>
        <div id="start-btn">Y ALLER</div>
    </div>

    <div id="game-container">
        <div id="flashlight"></div>
        <canvas id="gameCanvas"></canvas>
        
        <div id="hud">
            <div class="panel">
                <div id="zoneName" style="font-weight:bold; color:#fff; margin-bottom:5px;">CHARGEMENT...</div>
                <div style="font-size:12px; color:#aaa;">Paris, Nuit</div>
            </div>
            <div class="panel">
                <div style="color:#d4af37;">PREUVES : <span id="score" style="color:#fff;">0</span> / 3</div>
            </div>
        </div>

        <div id="dialogue-box"></div>

        <div id="win-screen">
            <h1 style="color:#d43737; font-family:'Courier New'; font-size:40px;">RETROUV√â.</h1>
            <img id="samuel-reveal" src="samuel.png" alt="Samuel">
            <p style="color:#666; cursor:pointer;" onclick="location.reload()">Recommencer</p>
        </div>
    </div>

    <script>
        // --- AUDIO ---
        var player; var tag = document.createElement('script'); tag.src = "https://www.youtube.com/iframe_api";
        var firstScriptTag = document.getElementsByTagName('script')[0]; firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        function onYouTubeIframeAPIReady() { player = new YT.Player('youtube-audio', { height: '0', width: '0', videoId: '0Z57bS8n_rY', playerVars: { 'autoplay': 0, 'controls': 0, 'loop': 1, 'playlist': '0Z57bS8n_rY' } }); }
        function changeMusic(id) { if(player && player.loadVideoById) player.loadVideoById(id); }

        // --- G√âN√âRATEUR ASSETS PIXEL ART ---
        const texSize = 128;
        function createTexture(type) {
            const c = document.createElement('canvas'); c.width = texSize; c.height = texSize; const x = c.getContext('2d');
            
            if(type === 'brick') { // Mur Ext√©rieur Vosges
                x.fillStyle = '#c44'; x.fillRect(0,0,texSize,texSize);
                x.fillStyle = '#922'; for(let i=0; i<400; i++) x.fillRect(Math.random()*texSize, Math.random()*texSize, 2, 2);
                x.fillStyle = '#333'; 
                for(let y=0; y<texSize; y+=16) {
                    x.fillRect(0, y, texSize, 2);
                    let off = (y/16)%2===0?0:16;
                    for(let xx=off; xx<texSize; xx+=32) x.fillRect(xx, y, 2, 16);
                }
                x.fillStyle = '#111'; x.fillRect(0, 110, texSize, 18); // Arcades base
            }
            else if(type === 'hedge') { // Haie Taill√©e
                x.fillStyle = '#0a1a0a'; x.fillRect(0,0,texSize,texSize);
                for(let i=0; i<1000; i++) {
                    x.fillStyle = Math.random()>0.6 ? '#1a3a0a' : '#2a5a1a';
                    x.fillRect(Math.random()*texSize, Math.random()*texSize, 3, 3);
                }
            }
            else if(type === 'grass') { // Herbe Parc
                x.fillStyle = '#0e1e0e'; x.fillRect(0,0,texSize,texSize);
                for(let i=0; i<600; i++) {
                    x.fillStyle = Math.random()>0.7 ? '#1e3e1e' : '#2e5e2e';
                    x.fillRect(Math.random()*texSize, Math.random()*texSize, 2, 2);
                }
            }
            else if(type === 'pigalle') { // Mur Crade
                x.fillStyle = '#222'; x.fillRect(0,0,texSize,texSize);
                x.fillStyle = '#111'; for(let i=0; i<20; i++) x.fillRect(0, Math.random()*texSize, texSize, 2); // Rayures
                x.fillStyle = '#a03'; for(let i=0; i<10; i++) x.fillRect(Math.random()*texSize, 60+Math.random()*40, 10, 20); // Graffiti
            }
            // OBJETS D√âCORATIFS (SPRITES)
            else if(type === 'lamp') {
                x.clearRect(0,0,texSize,texSize);
                x.fillStyle = '#222'; x.fillRect(60, 40, 8, 88); // Poteau
                x.fillStyle = '#ffc'; x.beginPath(); x.arc(64, 40, 10, 0, Math.PI*2); x.fill(); // Lumi√®re
                x.shadowColor='#ffc'; x.shadowBlur=20; x.beginPath(); x.arc(64, 40, 15, 0, Math.PI*2); x.fill();
            }
            else if(type === 'clue') {
                x.clearRect(0,0,texSize,texSize);
                x.fillStyle = '#fc0'; x.fillRect(40,80,48,32); x.fillStyle='#fff'; x.fillText('?', 60, 100);
            }
            return c;
        }
        
        const TEX_BRICK = createTexture('brick');
        const TEX_HEDGE = createTexture('hedge');
        const TEX_GRASS = createTexture('grass');
        const TEX_PIGALLE = createTexture('pigalle');
        const SPRITE_LAMP = createTexture('lamp');
        const SPRITE_CLUE = createTexture('clue');
        const samuelImg = new Image(); samuelImg.src = "samuel.png";

        // --- SC√âNARIO MESSAGERIE ---
        const messages = [
            { s: 'other', n: 'Clara', t: "C'est long ce cours de com..." },
            { s: 'other', n: 'L√©a', t: "Grave. On sort quand ?" },
            { s: 'him', n: 'Samuel', t: "AIDEZ-MOI" },
            { s: 'him', n: 'Samuel', t: "Je suis suivi." },
            { s: 'me', n: 'Moi', t: "Samuel ? Qu'est-ce qui se passe ?" },
            { s: 'him', n: 'Samuel', t: "üìç Position partag√©e : Place des Vosges." },
            { s: 'other', n: 'Clara', t: "OMG Sam, √ßa va ?!" },
            { s: 'me', n: 'Moi', t: "J'y vais. J'arrive." }
        ];
        
        let msgIndex = 0;
        function playIntro() {
            if(msgIndex >= messages.length) {
                document.getElementById('start-btn').style.display = 'block';
                return;
            }
            const m = messages[msgIndex];
            const div = document.createElement('div');
            div.className = `msg ${m.s === 'me' ? 'sent' : 'received'}`;
            let content = m.n ? `<div style="font-weight:bold;margin-bottom:5px;">${m.n}</div>` : '';
            content += m.t;
            div.innerHTML = `${content}<div class="timestamp">18:${30+msgIndex}</div>`;
            document.getElementById('chat-content').appendChild(div);
            msgIndex++;
            setTimeout(playIntro, 1000);
        }
        window.onload = playIntro;

        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('phone-screen').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            startGame();
        });

        // --- MOTEUR RAYCASTING OPTIMIS√â ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const GAME_WIDTH = 320; // Rendu basse r√©s pour perf et style r√©tro
        const GAME_HEIGHT = 180;
        canvas.width = GAME_WIDTH; canvas.height = GAME_HEIGHT;

        // Variables
        let posX = 0, posY = 0, dirX = 0, dirY = 0, planeX = 0, planeY = 0;
        let map = [];
        let sprites = []; // {x, y, tex, active}
        let currentLvl = 0;
        let clues = 0;
        let texWall, texFloor;
        let keys = {};

        // Niveaux
        // 1=Mur Ext√©rieur, 0=Vide, 2=Lampe, 5=Indice, 9=Sortie, 3=Haie Parc, 4=Herbe
        const L1_VOSGES = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],
            [1,0,2,0,0,2,0,1,0,2,0,0,2,0,0,1,0,0,2,0,0,2,0,1],
            [1,0,0,3,3,3,3,1,0,0,4,4,4,4,0,1,0,0,3,3,3,3,0,1], // Entr√©e Parc Nord
            [1,0,0,3,4,4,4,1,0,0,4,4,4,4,0,1,0,0,4,4,4,3,0,1],
            [1,0,0,3,4,4,4,3,3,0,4,4,4,4,0,3,3,0,4,4,4,3,0,1],
            [1,0,0,3,4,4,4,4,3,0,4,4,4,4,0,3,4,4,4,4,4,3,0,1],
            [1,1,1,1,0,0,3,4,3,0,4,4,4,4,0,3,4,3,0,0,1,1,1,1], // Entr√©es Parc Est/Ouest
            [1,0,0,0,0,0,3,4,3,0,4,5,4,5,0,3,4,3,0,0,0,0,0,1], // Indices Centre
            [1,0,0,0,0,0,0,0,0,0,4,4,4,4,0,0,0,0,0,0,0,0,0,1], // Grande all√©e centrale
            [1,0,0,0,0,0,3,4,3,0,4,4,5,4,0,3,4,3,0,0,0,0,0,1], // Indice Centre
            [1,1,1,1,0,0,3,4,3,0,4,4,4,4,0,3,4,3,0,0,1,1,1,1],
            [1,0,0,3,4,4,4,4,3,0,4,4,4,4,0,3,4,4,4,4,4,3,0,1],
            [1,0,0,3,4,4,4,3,3,0,4,4,4,4,0,3,3,0,4,4,4,3,0,1],
            [1,0,0,3,4,4,4,1,0,0,4,4,4,4,0,1,0,0,4,4,4,3,0,1],
            [1,0,0,3,3,3,3,1,0,0,4,4,4,4,0,1,0,0,3,3,3,3,0,1], // Entr√©e Parc Sud
            [1,0,0,2,0,0,2,0,1,0,2,0,0,2,0,0,1,0,0,2,0,0,2,0,1],
            [1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,9,1], // Sortie (9)
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        const L2_PIGALLE = [
            [1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,1,0,0,0,1],
            [1,0,2,0,0,0,0,2,0,1],
            [1,0,0,1,1,0,1,1,0,1],
            [1,0,5,1,0,0,0,1,0,1], // Rues larges (2 blocs min)
            [1,0,0,0,0,2,0,0,0,1],
            [1,0,1,0,1,1,1,0,1,1],
            [1,0,1,0,5,1,5,0,0,1],
            [1,0,0,0,0,1,0,0,0,1],
            [1,0,2,0,8,1,0,2,0,1], // 8 = Samuel
            [1,1,1,1,1,1,1,1,1,1]
        ];

        const NARRATIVE = [
            ["Sa carte d'√©tudiant ESG.", "Une page de cours de Philo d√©chir√©e.", "Son bonnet. Il g√®le."],
            ["Un couteau suisse. Pas le sien.", "Son sac √† dos ouvert.", "Le dossier des Archives !"]
        ];

        function loadLevel(idx) {
            currentLvl = idx;
            clues = 0;
            document.getElementById('score').innerText = "0";
            
            // Configuration
            if(idx === 0) {
                map = L1_VOSGES; texWall = TEX_BRICK; texFloor = TEX_GRASS;
                posX = 1.5; posY = 1.5; dirX = 1; dirY = 0;
                planeX = 0; planeY = 0.66;
                document.getElementById('zoneName').innerText = "PLACE DES VOSGES";
                changeMusic('0Z57bS8n_rY');
            } else {
                map = L2_PIGALLE; texWall = TEX_PIGALLE; texFloor = TEX_PIGALLE;
                posX = 1.5; posY = 1.5; dirX = 0; dirY = 1; // D√©part vers le sud
                planeX = -0.66; planeY = 0;
                document.getElementById('zoneName').innerText = "RUE PIGALLE";
                changeMusic('vvHCLeS0bCY');
            }

            // Extraction Sprites
            sprites = [];
            let clueCount = 0;
            for(let x=0; x<map.length; x++) { // Inversion X/Y pour lecture tableau facile
                for(let y=0; y<map[0].length; y++) {
                    let val = map[x][y];
                    if(val === 2) sprites.push({x: x+0.5, y: y+0.5, type: 'lamp', active: true});
                    if(val === 5) {
                        sprites.push({x: x+0.5, y: y+0.5, type: 'clue', active: true, txt: NARRATIVE[idx][clueCount] || "Preuve."});
                        map[x][y] = 0; // On retire du mur physique
                        clueCount++;
                    }
                    if(val === 8) {
                        sprites.push({x: x+0.5, y: y+0.5, type: 'samuel', active: true});
                        map[x][y] = 0;
                    }
                }
            }
        }

        // --- BOUCLE PRINCIPALE ---
        function startGame() {
            loadLevel(0);
            window.addEventListener('keydown', e => keys[e.key] = true);
            window.addEventListener('keyup', e => keys[e.key] = false);
            requestAnimationFrame(gameLoop);
        }

        function gameLoop() {
            // 1. MOUVEMENT (GLISSANT)
            let moveSpeed = keys['Shift'] ? 0.08 : 0.04;
            let rotSpeed = 0.035;

            // Rotation
            if (keys['ArrowRight']) {
                let oldDirX = dirX;
                dirX = dirX * Math.cos(-rotSpeed) - dirY * Math.sin(-rotSpeed);
                dirY = oldDirX * Math.sin(-rotSpeed) + dirY * Math.cos(-rotSpeed);
                let oldPlaneX = planeX;
                planeX = planeX * Math.cos(-rotSpeed) - planeY * Math.sin(-rotSpeed);
                planeY = oldPlaneX * Math.sin(-rotSpeed) + planeY * Math.cos(-rotSpeed);
            }
            if (keys['ArrowLeft']) {
                let oldDirX = dirX;
                dirX = dirX * Math.cos(rotSpeed) - dirY * Math.sin(rotSpeed);
                dirY = oldDirX * Math.sin(rotSpeed) + dirY * Math.cos(rotSpeed);
                let oldPlaneX = planeX;
                planeX = planeX * Math.cos(rotSpeed) - planeY * Math.sin(rotSpeed);
                planeY = oldPlaneX * Math.sin(rotSpeed) + planeY * Math.cos(rotSpeed);
            }

            // D√©placement Vectoriel
            let moveStep = 0;
            if(keys['ArrowUp']) moveStep = 1;
            if(keys['ArrowDown']) moveStep = -1;

            if(moveStep !== 0) {
                let nextX = posX + dirX * moveSpeed * moveStep;
                let nextY = posY + dirY * moveSpeed * moveStep;

                // Collision X avec "Glissade" (Murs 1 et 3)
                if(map[Math.floor(nextX)][Math.floor(posY)] === 0 || map[Math.floor(nextX)][Math.floor(posY)] === 9 || map[Math.floor(nextX)][Math.floor(posY)] === 4) {
                    posX = nextX;
                }
                // Collision Y avec "Glissade" (Murs 1 et 3)
                if(map[Math.floor(posX)][Math.floor(nextY)] === 0 || map[Math.floor(posX)][Math.floor(nextY)] === 9 || map[Math.floor(posX)][Math.floor(nextY)] === 4) {
                    posY = nextY;
                }

                // Check Sortie (9)
                if(map[Math.floor(posX)][Math.floor(posY)] === 9) {
                    if(clues >= 3) {
                         if(currentLvl === 0) loadLevel(1);
                    } else {
                        // Repousse doucement
                        posX -= dirX * 0.2; posY -= dirY * 0.2;
                        showDialog("Je ne peux pas partir. Il manque des preuves.");
                    }
                }
            }

            // Interaction Sprites
            sprites.forEach(s => {
                if(!s.active) return;
                let d = Math.sqrt((posX - s.x)**2 + (posY - s.y)**2);
                if(d < 0.5) {
                    if(s.type === 'clue') {
                        s.active = false; clues++;
                        document.getElementById('score').innerText = clues;
                        showDialog(s.txt);
                    }
                    if(s.type === 'samuel') {
                        document.getElementById('win-screen').style.display = 'flex';
                    }
                }
            });

            // 2. RENDU (Raycasting)
            // Sol et Ciel d√©grad√©
            let grd = ctx.createLinearGradient(0,0,0,GAME_HEIGHT);
            grd.addColorStop(0, "#050510"); grd.addColorStop(0.5, "#000"); grd.addColorStop(1, "#151515");
            ctx.fillStyle = grd; ctx.fillRect(0,0,GAME_WIDTH, GAME_HEIGHT);

            // Murs
            for(let x = 0; x < GAME_WIDTH; x++) {
                let cameraX = 2 * x / GAME_WIDTH - 1;
                let rayDirX = dirX + planeX * cameraX;
                let rayDirY = dirY + planeY * cameraX;

                let mapX = Math.floor(posX);
                let mapY = Math.floor(posY);

                let sideDistX, sideDistY;
                let deltaDistX = Math.abs(1/rayDirX);
                let deltaDistY = Math.abs(1/rayDirY);
                let perpWallDist;
                let stepX, stepY;
                let hit = 0; let side;

                if(rayDirX < 0) { stepX = -1; sideDistX = (posX - mapX) * deltaDistX; }
                else { stepX = 1; sideDistX = (mapX + 1.0 - posX) * deltaDistX; }
                if(rayDirY < 0) { stepY = -1; sideDistY = (posY - mapY) * deltaDistY; }
                else { stepY = 1; sideDistY = (mapY + 1.0 - posY) * deltaDistY; }

                while(hit === 0) {
                    if(sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
                    else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
                    // Murs physiques : 1 (Brique Ext) et 3 (Haie)
                    if(map[mapX][mapY] === 1 || map[mapX][mapY] === 3) hit = 1;
                }

                if(side === 0) perpWallDist = (mapX - posX + (1 - stepX) / 2) / rayDirX;
                else           perpWallDist = (mapY - posY + (1 - stepY) / 2) / rayDirY;

                let lineHeight = Math.floor(GAME_HEIGHT / perpWallDist);
                let drawStart = -lineHeight / 2 + GAME_HEIGHT / 2;
                if(drawStart < 0) drawStart = 0;
                let drawEnd = lineHeight / 2 + GAME_HEIGHT / 2;
                if(drawEnd >= GAME_HEIGHT) drawEnd = GAME_HEIGHT - 1;

                // Texture calculation
                let wallX;
                if (side == 0) wallX = posY + perpWallDist * rayDirY;
                else           wallX = posX + perpWallDist * rayDirX;
                wallX -= Math.floor(wallX);
                let texX = Math.floor(wallX * texSize);
                if(side == 0 && rayDirX > 0) texX = texSize - texX - 1;
                if(side == 1 && rayDirY < 0) texX = texSize - texX - 1;

                // Rendu colonne
                let brightness = Math.max(0, 1 - perpWallDist/8); // Brouillard
                ctx.globalAlpha = 1;
                
                // Choix texture
                let tex = map[mapX][mapY] === 1 ? texWall : TEX_HEDGE;
                ctx.drawImage(tex, texX, 0, 1, texSize, x, drawStart, 1, drawEnd - drawStart);
                
                // Ombre
                ctx.fillStyle = `rgba(0,0,0,${1-brightness})`;
                ctx.fillRect(x, drawStart, 1, drawEnd - drawStart);
            }

            // 3. SPRITES (Lampes, Indices)
            // Calcul distance pour tri
            sprites.forEach(s => s.dist = ((posX - s.x)**2 + (posY - s.y)**2));
            sprites.sort((a,b) => b.dist - a.dist);

            sprites.forEach(sprite => {
                if(!sprite.active) return;
                let spriteX = sprite.x - posX;
                let spriteY = sprite.y - posY;

                let invDet = 1.0 / (planeX * dirY - dirX * planeY);
                let transformX = invDet * (dirY * spriteX - dirX * spriteY);
                let transformY = invDet * (-planeY * spriteX + planeX * spriteY);

                let spriteScreenX = Math.floor((GAME_WIDTH / 2) * (1 + transformX / transformY));
                let spriteHeight = Math.abs(Math.floor(GAME_HEIGHT / transformY));
                let spriteWidth = Math.abs(Math.floor(GAME_HEIGHT / transformY));
                let drawStartY = -spriteHeight / 2 + GAME_HEIGHT / 2;
                if(drawStartY < 0) drawStartY = 0;
                let drawStartX = -spriteWidth / 2 + spriteScreenX;
                if(drawStartX < 0) drawStartX = 0;
                let drawEndX = spriteWidth / 2 + spriteScreenX;
                if(drawEndX >= GAME_WIDTH) drawEndX = GAME_WIDTH - 1;

                if(transformY > 0 && transformX > -1 && transformX < 1) {
                    let img = SPRITE_CLUE;
                    if(sprite.type === 'lamp') img = SPRITE_LAMP;
                    if(sprite.type === 'samuel') img = samuelImg;
                    ctx.drawImage(img, drawStartX, drawStartY, drawEndX - drawStartX, spriteHeight);
                }
            });

            requestAnimationFrame(gameLoop);
        }

        function showDialog(txt) {
            const el = document.getElementById('dialogue-box');
            el.innerText = txt; el.style.display = 'block';
            setTimeout(() => el.style.display = 'none', 4000);
        }

    </script>
</body>
</html>
