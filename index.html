<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mission: Samuel Ã  Paris</title>
    <style>
        :root {
            --neon-pink: #FF006E; --neon-blue: #00F5FF; --neon-purple: #8B5CF6; --neon-green: #10B981;
            --bg: #0A0E27; --surface: #1A1F3A; --gold: #FFD700; --text: #F9FAFB;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        body {
            background: radial-gradient(circle, var(--surface), var(--bg));
            font-family: 'Segoe UI', sans-serif; color: var(--text);
            overflow: hidden; width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center;
        }
        /* Scanlines */
        .scanlines {
            position: fixed; inset: 0; pointer-events: none; z-index: 999;
            background: repeating-linear-gradient(0deg, rgba(0,0,0,0.1) 0px, transparent 1px, transparent 2px);
            background-size: 100% 4px; animation: scan 10s linear infinite;
        }
        @keyframes scan { from { background-position: 0 0; } to { background-position: 0 100%; } }

        /* UI Elements */
        #title-screen, #gameover-screen {
            position: fixed; inset: 0; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 1000;
            background: rgba(5, 8, 22, 0.95); transition: opacity 0.5s;
        }
        .hidden { opacity: 0; pointer-events: none; }
        h1 {
            font-size: clamp(40px, 8vw, 70px); text-transform: uppercase;
            text-shadow: 0 0 20px var(--neon-purple); animation: glitch 3s infinite;
        }
        @keyframes glitch {
            0%, 100% { text-shadow: 2px 2px var(--neon-pink), -2px -2px var(--neon-blue); }
            50% { text-shadow: -2px 2px var(--neon-blue), 2px -2px var(--neon-pink); }
        }

        /* Phone & Chat */
        #phone-container {
            width: min(380px, 95vw); height: min(750px, 90vh);
            background: #111; border: 10px solid #222; border-radius: 30px;
            display: flex; flex-direction: column; overflow: hidden;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8); z-index: 500;
            opacity: 0; transform: translateY(50px); transition: 0.5s;
        }
        #phone-container.visible { opacity: 1; transform: translateY(0); }
        #chat-body { flex: 1; padding: 15px; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; background: #000; }
        .msg {
            max-width: 80%; padding: 10px 15px; border-radius: 15px; font-size: 14px;
            animation: pop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .left { background: #333; align-self: flex-start; border-bottom-left-radius: 2px; }
        .right { background: var(--neon-purple); align-self: flex-end; border-bottom-right-radius: 2px; }
        .sender { font-size: 10px; opacity: 0.7; display: block; margin-bottom: 2px; }
        
        button {
            padding: 15px; background: linear-gradient(90deg, var(--neon-pink), var(--neon-purple));
            border: none; color: white; font-weight: bold; font-size: 16px;
            cursor: pointer; text-transform: uppercase; letter-spacing: 1px;
        }
        button:hover { filter: brightness(1.2); }

        /* Game & HUD */
        #game-container { position: fixed; inset: 0; display: none; justify-content: center; align-items: center; z-index: 100; }
        canvas { border: 2px solid var(--neon-purple); border-radius: 8px; box-shadow: 0 0 30px rgba(139, 92, 246, 0.3); background: #000; max-width: 100vw; max-height: 100vw; }
        
        #hud {
            position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
            display: none; gap: 15px; z-index: 200;
        }
        .hud-panel {
            background: rgba(26, 31, 58, 0.9); padding: 8px 15px; border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.1); text-align: center;
        }
        .hud-val { display: block; font-size: 20px; font-weight: bold; color: var(--gold); }
        .hud-lbl { font-size: 10px; color: #999; text-transform: uppercase; }
        .items { display: flex; gap: 5px; margin-top: 5px; }
        .slot { width: 25px; height: 25px; background: rgba(0,0,0,0.5); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 16px; }
        .slot.got { background: var(--neon-green); box-shadow: 0 0 10px var(--neon-green); }

        /* Notification */
        #notif {
            position: fixed; top: 80px; left: 50%; transform: translate(-50%, -20px);
            background: rgba(0,0,0,0.9); border: 1px solid var(--neon-pink);
            padding: 10px 20px; border-radius: 20px; font-weight: bold;
            opacity: 0; transition: 0.3s; z-index: 900; pointer-events: none;
        }
        #notif.show { transform: translate(-50%, 0); opacity: 1; }

        @keyframes pop { from { transform: scale(0); } to { transform: scale(1); } }
    </style>
</head>
<body>
    <div class="scanlines"></div>

    <div id="title-screen">
        <h1>MISSION: SAMUEL</h1>
        <p style="letter-spacing: 5px; color: #888;">Ã€ PARIS</p>
    </div>

    <div id="phone-container">
        <div style="background: #222; padding: 15px; text-align: center; font-weight: bold;">ðŸ’¬ MESSAGE</div>
        <div id="chat-body"></div>
        <button id="btn-start" style="display:none;">ðŸš€ PARTIR EN MISSION</button>
    </div>

    <div id="game-container"><canvas id="canvas" width="800" height="800"></canvas></div>
    
    <div id="hud">
        <div class="hud-panel"><span class="hud-lbl">Score</span><span class="hud-val" id="score">0</span></div>
        <div class="hud-panel">
            <span class="hud-lbl">Indices</span>
            <div class="items"><div class="slot" id="s0"></div><div class="slot" id="s1"></div><div class="slot" id="s2"></div></div>
        </div>
        <div class="hud-panel"><span class="hud-lbl">Niveau</span><span class="hud-val" id="level">1</span></div>
    </div>

    <div id="notif"></div>

    <div id="gameover-screen" class="hidden">
        <h1 id="go-title">GAME OVER</h1>
        <div style="margin: 20px; font-size: 20px;">Score: <span id="final-score" style="color:var(--gold)">0</span></div>
        <button onclick="location.reload()">ðŸ”„ REJOUER</button>
    </div>

    <script>
        // --- CONSTANTS ---
        const TILE = 40, GRID = 20;
        
        // --- AUDIO ---
        const audio = {
            ctx: null,
            init() { 
                if(!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
                if(this.ctx.state === 'suspended') this.ctx.resume();
            },
            play(type) {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain); gain.connect(this.ctx.destination);
                
                const now = this.ctx.currentTime;
                if(type === 'msg') {
                    osc.frequency.setValueAtTime(600, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(); osc.stop(now + 0.1);
                } else if(type === 'item') {
                    osc.frequency.setValueAtTime(800, now);
                    osc.frequency.linearRampToValueAtTime(1200, now + 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    osc.start(); osc.stop(now + 0.2);
                } else if(type === 'bump') {
                    osc.type = 'square'; osc.frequency.value = 150;
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(); osc.stop(now + 0.1);
                } else if(type === 'win') {
                    osc.type = 'triangle';
                    [523, 659, 784].forEach((f, i) => {
                        const o = this.ctx.createOscillator();
                        const g = this.ctx.createGain();
                        o.connect(g); g.connect(this.ctx.destination);
                        o.frequency.value = f;
                        g.gain.setValueAtTime(0.1, now + i*0.1);
                        g.gain.linearRampToValueAtTime(0, now + i*0.1 + 0.3);
                        o.start(now + i*0.1); o.stop(now + i*0.1 + 0.3);
                    });
                } else if(type === 'hit') {
                    osc.type = 'sawtooth'; osc.frequency.value = 100;
                    gain.gain.linearRampToValueAtTime(0, now + 0.3);
                    osc.start(); osc.stop(now + 0.3);
                }
            }
        };

        // --- GAME ENGINE ---
        class Game {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.entities = [];
                this.state = 'MENU';
                this.score = 0;
                this.levelIdx = 0;
                this.itemsCollected = 0;
                this.itemsTotal = 3;
                this.lastTime = 0;
                
                this.player = { x: 1, y: 1, px: 60, py: 60, tx: 60, ty: 60, moving: false };
                this.map = [];
                
                // Inputs
                window.addEventListener('keydown', e => this.handleInput(e));
                
                // Touch
                let tsX, tsY;
                this.canvas.addEventListener('touchstart', e => { tsX = e.touches[0].clientX; tsY = e.touches[0].clientY; });
                this.canvas.addEventListener('touchend', e => {
                    const dx = e.changedTouches[0].clientX - tsX;
                    const dy = e.changedTouches[0].clientY - tsY;
                    if(Math.abs(dx) > Math.abs(dy)) this.move(dx > 0 ? 1 : -1, 0);
                    else this.move(0, dy > 0 ? 1 : -1);
                });
            }

            init() {
                this.state = 'PLAYING';
                document.getElementById('game-container').style.display = 'flex';
                document.getElementById('hud').style.display = 'flex';
                document.getElementById('phone-container').style.display = 'none';
                this.loadLevel();
                requestAnimationFrame(t => this.loop(t));
            }

            loadLevel() {
                // Generate simple map
                this.map = [];
                for(let y=0; y<GRID; y++) {
                    this.map[y] = [];
                    for(let x=0; x<GRID; x++) {
                        // Borders and random blocks
                        this.map[y][x] = (x===0 || x===GRID-1 || y===0 || y===GRID-1 || (Math.random()<0.1 && x>2 && y>2)) ? 1 : 0;
                    }
                }
                
                // Clear start/end area
                this.map[1][1] = 0; this.map[18][18] = 0;
                
                this.player.x = 1; this.player.y = 1;
                this.syncPlayerPos();
                
                // Spawn Items
                this.entities = [];
                for(let i=0; i<3; i++) this.spawnEntity('item');
                // Spawn Enemies
                const enemyCount = 3 + this.levelIdx;
                for(let i=0; i<enemyCount; i++) this.spawnEntity('enemy');

                this.itemsCollected = 0;
                this.updateHud();
                this.notify(`NIVEAU ${this.levelIdx + 1}`);
            }

            spawnEntity(type) {
                let ex, ey;
                do {
                    ex = Math.floor(Math.random() * (GRID-2)) + 1;
                    ey = Math.floor(Math.random() * (GRID-2)) + 1;
                } while(this.map[ey][ex] === 1 || (ex<4 && ey<4));
                this.entities.push({ type, x: ex, y: ey, px: ex*TILE+20, py: ey*TILE+20 });
            }

            handleInput(e) {
                if(this.state !== 'PLAYING' || this.player.moving) return;
                if(e.key.startsWith('Arrow')) {
                    const dx = e.key === 'ArrowLeft' ? -1 : e.key === 'ArrowRight' ? 1 : 0;
                    const dy = e.key === 'ArrowUp' ? -1 : e.key === 'ArrowDown' ? 1 : 0;
                    this.move(dx, dy);
                }
            }

            move(dx, dy) {
                const nx = this.player.x + dx, ny = this.player.y + dy;
                if(this.map[ny][nx] === 0) {
                    this.player.x = nx; this.player.y = ny;
                    this.player.tx = nx * TILE + 20; this.player.ty = ny * TILE + 20;
                    this.player.moving = true;
                } else {
                    audio.play('bump');
                }
            }

            update(dt) {
                // Player lerp
                if(this.player.moving) {
                    const dx = this.player.tx - this.player.px;
                    const dy = this.player.ty - this.player.py;
                    if(Math.sqrt(dx*dx + dy*dy) < 2) {
                        this.syncPlayerPos();
                        this.player.moving = false;
                        this.checkCollision();
                    } else {
                        this.player.px += dx * 10 * dt;
                        this.player.py += dy * 10 * dt;
                    }
                }

                // Enemy AI
                this.entities.filter(e => e.type === 'enemy').forEach(e => {
                    e.t = (e.t || 0) + dt;
                    if(e.t > 0.5) { // Slow movement
                         e.px += (Math.random()-0.5) * 2; // Shake effect
                         e.py += (Math.random()-0.5) * 2;
                         if(Math.random() < 0.05) { // Move randomly
                             const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
                             const d = dirs[Math.floor(Math.random()*4)];
                             if(this.map[e.y+d[1]] && this.map[e.y+d[1]][e.x+d[0]] === 0) {
                                 e.x += d[0]; e.y += d[1];
                                 e.px = e.x * TILE + 20; e.py = e.y * TILE + 20;
                             }
                         }
                         e.t = 0;
                    }
                    // Simple collision with player
                    if(Math.round(e.x) === this.player.x && Math.round(e.y) === this.player.y) {
                        this.gameOver();
                    }
                });
            }

            checkCollision() {
                // Collect Items
                const itemIdx = this.entities.findIndex(e => e.type === 'item' && e.x === this.player.x && e.y === this.player.y);
                if(itemIdx !== -1) {
                    this.entities.splice(itemIdx, 1);
                    this.itemsCollected++;
                    this.score += 100;
                    audio.play('item');
                    this.updateHud();
                    this.notify("INDICE RÃ‰CUPÃ‰RÃ‰ !");
                }

                // Exit
                if(this.player.x === 18 && this.player.y === 18) {
                    if(this.itemsCollected === 3) {
                        audio.play('win');
                        if(this.levelIdx < 1) {
                            this.levelIdx++;
                            this.loadLevel();
                        } else {
                            this.endGame(true);
                        }
                    } else {
                        this.notify("IL MANQUE DES INDICES !");
                    }
                }
            }

            syncPlayerPos() {
                this.player.px = this.player.x * TILE + 20;
                this.player.py = this.player.y * TILE + 20;
            }

            draw() {
                this.ctx.fillStyle = '#050816';
                this.ctx.fillRect(0, 0, 800, 800);

                // Map
                for(let y=0; y<GRID; y++) {
                    for(let x=0; x<GRID; x++) {
                        if(this.map[y][x]===1) {
                            this.ctx.fillStyle = '#1A1F3A';
                            this.ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
                            this.ctx.strokeStyle = '#2d2d2d';
                            this.ctx.strokeRect(x*TILE, y*TILE, TILE, TILE);
                        }
                    }
                }

                // Exit
                this.ctx.fillStyle = this.itemsCollected===3 ? '#00F5FF' : '#555';
                this.ctx.beginPath(); this.ctx.arc(18*TILE+20, 18*TILE+20, 15, 0, Math.PI*2); this.ctx.fill();
                this.ctx.fillStyle = '#000'; this.ctx.fillText("EXIT", 18*TILE+8, 18*TILE+24);

                // Entities
                this.entities.forEach(e => {
                    if(e.type === 'item') {
                        this.ctx.fillStyle = '#FFD700';
                        this.ctx.font = '20px Arial';
                        this.ctx.fillText('ðŸ“„', e.px-10, e.py+8);
                    } else if(e.type === 'enemy') {
                        this.ctx.fillStyle = '#FF006E';
                        this.ctx.beginPath(); this.ctx.arc(e.px, e.py, 12, 0, Math.PI*2); this.ctx.fill();
                        this.ctx.fillText('ðŸ¦', e.px-10, e.py+5);
                    }
                });

                // Player
                this.ctx.fillStyle = '#00F5FF';
                this.ctx.shadowBlur = 15; this.ctx.shadowColor = '#00F5FF';
                this.ctx.beginPath(); this.ctx.arc(this.player.px, this.player.py, 10, 0, Math.PI*2); this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }

            loop(t) {
                if(this.state !== 'PLAYING') return;
                const dt = (t - this.lastTime) / 1000 || 0;
                this.lastTime = t;
                this.update(dt);
                this.draw();
                requestAnimationFrame(t2 => this.loop(t2));
            }

            updateHud() {
                document.getElementById('score').innerText = this.score;
                for(let i=0; i<3; i++) {
                    const el = document.getElementById(`s${i}`);
                    if(i < this.itemsCollected) { el.classList.add('got'); el.innerHTML = 'âœ“'; }
                    else { el.classList.remove('got'); el.innerHTML = ''; }
                }
                document.getElementById('level').innerText = this.levelIdx + 1;
            }

            notify(msg) {
                const n = document.getElementById('notif');
                n.innerText = msg; n.classList.add('show');
                setTimeout(() => n.classList.remove('show'), 2000);
            }

            gameOver() {
                audio.play('hit');
                this.endGame(false);
            }

            endGame(win) {
                this.state = 'GAMEOVER';
                const scr = document.getElementById('gameover-screen');
                scr.classList.remove('hidden');
                document.getElementById('go-title').innerText = win ? "SAMUEL RETROUVÃ‰ !" : "ECHEC MISSION";
                document.getElementById('go-title').style.color = win ? "#10B981" : "#FF006E";
                document.getElementById('final-score').innerText = this.score;
            }
        }

        // --- SCENARIO & CHAT ---
        const chat = [
            { s: "Samuel", t: "Mec, t'es oÃ¹ ?!", self: false },
            { s: "Moi", t: "J'arrive Ã  Paris ! T'es Ã  Pigalle ?", self: true },
            { s: "Samuel", t: "Ouais, mais j'ai perdu mes papiers...", self: false },
            { s: "Samuel", t: "J'ai laissÃ© 3 indices dans le parc, mais y'a des pigeons agressifs !", self: false },
            { s: "Moi", t: "Des pigeons ? T'es sÃ©rieux ? ðŸ˜…", self: true },
            { s: "System", t: "MISSION : Collecte les indices. Ã‰vite les pigeons.", self: false }
        ];

        const game = new Game();
        let msgIdx = 0;

        function nextMsg() {
            if(msgIdx >= chat.length) {
                document.getElementById('btn-start').style.display = 'block';
                return;
            }
            const m = chat[msgIdx];
            const d = document.createElement('div');
            d.className = `msg ${m.self ? 'right' : 'left'}`;
            d.innerHTML = `<span class="sender">${m.s}</span>${m.t}`;
            document.getElementById('chat-body').appendChild(d);
            document.getElementById('chat-body').scrollTop = 9999;
            audio.play('msg');
            msgIdx++;
            setTimeout(nextMsg, m.self ? 1000 : 1500);
        }

        // --- INIT ---
        setTimeout(() => {
            document.getElementById('title-screen').style.opacity = 0;
            setTimeout(() => {
                document.getElementById('title-screen').style.display = 'none';
                document.getElementById('phone-container').classList.add('visible');
                setTimeout(nextMsg, 500);
            }, 500);
        }, 2000);

        document.getElementById('btn-start').onclick = () => {
            audio.init(); // Important for browser policy
            audio.play('win'); // Start sound
            game.init();
        };
    </script>
</body>
</html>
